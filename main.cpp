#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#include "lib/aux_tools.h"
#include "lib/my_types.h"

#include "lib/database.hpp"

// ----------------------------------------------------------------------------

#define N_READERS 3    // Number of readers
#define READER_STEPS 2 // Number of reader actions
#define WRITER_STEPS 4 // Number of writer actions
#define FRAME_STEP (int) (0.1 * 1e6) // (int) (SECONDS * 1e6) MICROSECONDS
#define MAX_DELAY    5 // Maximum number of FRAME_STEPS in a delay

#define WRITER_STRING_SIZE 10 // Size of new string to be written by writer
#define WRITER_MAX_ID 1000 // Maximum ID that can be generated by writer

#define ACTION_GET_ID    0 // Makes reader get elements by id
#define ACTION_GET_NAME  1 // Makes reader get elements by name
#define ACTION_GET_VALUE 2 // Makes reader get elements by value
#define READER_ACTIONS   3 // Number of possible reader actions

#define DB_NAME "database" // Database name

// ----------------------------------------------------------------------------

sem_t mutex;     // Mutex semaphore
sem_t db_access; // Database access semaphore
sem_t request;   // Writer semaphore

unsigned int num_of_readers = 0; // Number of readers reading

database db(DB_NAME); // The Database

// ----------------------------------------------------------------------------

void lock_reader(int id);      // Increment number of readers
void unlock_reader(int id);    // Decrement number of readers
void *reader_func(void *args); // Reader thread function/behavior
void *writer_func(void *args); // Writer thread function/behavior

// ----------------------------------------------------------------------------

void thread_simulation() {
	// Initializing synchronizers ---------------------------------------------
	pthread_t reader_id[N_READERS]; // ID of readers
	pthread_t writer_id;            // ID of writer

	thread_args reader_args[N_READERS], // arguments of readers
	            writer_args;            // arguments of writer

	sem_init(&mutex, 0, 1);         // intialize mutex
	sem_init(&db_access, 0, 1);     // initialize database semaphore
	sem_init(&request, 0, 1);     //
	// ------------------------------------------------------------------------

	// Generating seeds -------------------------------------------------------
	srand(time(NULL));                  //
	for(int i = 0; i < N_READERS ; i++) // generating seeds
		reader_args[i].seed = rand();   //
	writer_args.seed = rand();          //
	// ------------------------------------------------------------------------
	
	// Creating threads -------------------------------------------------------
	for(int i = 0; i < N_READERS; i++) {
		reader_args[i].id = i;
		pthread_create (&reader_id[i], // id
			            NULL,          // 
			            reader_func,   // thread function
			            (void *) &reader_args[i]); // argumento for thread function
	}

	writer_args.id = N_READERS; // writer has the last ID
	pthread_create(&writer_id,  // id
		           NULL,        //
		           writer_func, // thread function
		           (void *) &writer_args); // argument for thread function
	// ------------------------------------------------------------------------

	// Joining threads --------------------------------------------------------
	for(int i = 0; i < N_READERS; i++) // wait all threads to finish
 		pthread_join(reader_id[i], NULL);
 	pthread_join(writer_id, NULL);
	// ------------------------------------------------------------------------
}

int main(int argc, char* argv[]) {
	// Checking database ------------------------------------------------------
	// db.create_dummy(1000); // uncomment this line to create a dummy database
	if(!db.is_available())
		exit(EXIT_FAILURE);
	// ------------------------------------------------------------------------
	thread_simulation(); // if creating dummy database, comment this line

	return EXIT_SUCCESS;
}

// ----------------------------------------------------------------------------

void lock_reader(int id) {
	sem_wait(&mutex);
	num_of_readers++;
	message("[READER >>]: " + std::to_string(id) + " locked db (" + std::to_string(num_of_readers) + " reading)");
	sem_post(&mutex);
}

void unlock_reader(int id) {
	sem_wait(&mutex);
	num_of_readers--;	
	message("[READER >>]: " + std::to_string(id) + " unlocked db (" + std::to_string(num_of_readers) + " reading)");
	sem_post(&mutex);
}

void *reader_func(void *_args) {
	thread_args *args = (thread_args *) _args;
	
	unsigned int id = args->id,
	             seed = args->seed;

	sem_wait(&mutex);
	std::cout << "[READER >>]: " << id << " is ONLINE\n";
	sem_post(&mutex);

	for(int i = 0; i < READER_STEPS; i++) {
		int action = (int) (rand_prob(&seed) * READER_ACTIONS),
		    set_delay = (int) (rand_prob(&seed) * MAX_DELAY);

		double lower_val = rand_value(&seed),
			   upper_val = rand_value(&seed);

		if(lower_val > upper_val) {
			double aux = lower_val;
			lower_val = upper_val;
			upper_val = aux;
		}

		int lower_id = (int) (WRITER_MAX_ID * rand_prob(&seed)),
			upper_id = (int) (WRITER_MAX_ID * rand_prob(&seed));

		if(lower_id > upper_id) {
			int aux = lower_id;
			lower_id = upper_id;
			upper_id = aux;
		}

		word lower_name = rand_string(WRITER_STRING_SIZE, &seed),
			 upper_name = rand_string(WRITER_STRING_SIZE, &seed);

		if(lower_name.compare(upper_name) > 0) {
			word aux = lower_name;
			lower_name = upper_name;
			upper_name = aux;
		}

		sem_wait(&request);
		sem_post(&request);		    
		lock_reader(id);

		switch(action) {
			case ACTION_GET_ID:
				sem_wait(&mutex);
				message("[READER >>]: " + std::to_string(id) + " will get element by id");
				sem_post(&mutex);

				sem_wait(&db_access);
				db.get_id(lower_id, upper_id, false);
				sem_post(&db_access);
				break;

			case ACTION_GET_NAME:
				sem_wait(&mutex);
				message("[READER >>]: " + std::to_string(id) + " will get element by name");
				sem_post(&mutex);

				sem_wait(&db_access);
				db.get_name(lower_name, upper_name, false);
				sem_post(&db_access);
				break;

			case ACTION_GET_VALUE:
				sem_wait(&mutex);
				message("[READER >>]: " + std::to_string(id) + " will get element by value");
				sem_post(&mutex);

				sem_wait(&db_access);
				db.get_value(lower_val, upper_val, false);
				sem_post(&db_access);
				break;

			default:
				break;
		}
		
		unlock_reader(id);
		usleep(set_delay);		
	}

	sem_wait(&mutex);
	std::cout << "[READER >>]: " << id << " is OFFLINE\n";
	sem_post(&mutex);

	return NULL;
}

void *writer_func(void *_args) {
	thread_args *args = (thread_args *) _args;
	
	unsigned int id = args->id,
	             seed = args->seed;

	sem_wait(&mutex);
	std::cout << "[<< WRITER]: " << id << " is ONLINE\n";
	sem_post(&mutex);

	for(int i = 0; i < WRITER_STEPS; i++) {
		int set_delay = (int) (rand_prob(&seed) * MAX_DELAY);

		double new_value = rand_value(&seed);
		word new_word = rand_string(WRITER_STRING_SIZE, &seed);
		
		sem_wait(&request);

		sem_wait(&mutex);
		message("[<< WRITER]: " + std::to_string(id) + " locked db for new readers (" + std::to_string(num_of_readers) + " reading)");
		sem_post(&mutex);

		sem_wait(&db_access);
		bool success = db.insert(new_word, new_value);
		sem_post(&db_access);

		sem_wait(&mutex);
		if(!success)
			message("[<< WRITER]: " + std::to_string(id) + " couldn't insert");
		else
			message("[<< WRITER]: " + std::to_string(id) + " inserted");
		sem_post(&mutex);

		sem_wait(&mutex);
		message("[<< WRITER]: " + std::to_string(id) + " unlocked db");
		sem_post(&mutex);

		sem_post(&request);

		usleep(set_delay);
	}

	sem_wait(&mutex);
	std::cout << "[<< WRITER]: " << id << " is OFFLINE\n";
	sem_post(&mutex);

	return NULL;
}
